=== Annex C 
=== (informative)
=== Best-practice: A GeoSPARQL-enabled triple stores as a backend of an OGC web service

This annex wants to present best practices of creating linked data backends to OGC webservices.

==== C.1 Accessing geospatial features in a SPARQL endpoint

Geospatial features in SPARQL endpoints as defined in the GeoSPARQL standard are instances of subclasses of http://www.opengis.net/ont/geosparql#Feature[geo:Feature].
They include one or many http://www.opengis.net/ont/geosparql#hasGeometry[geo:hasGeometry] relations and a set of further properties which may or may not refer to further instances related to the geospatial feature. 
Similarly to SQL backends of OGC webservices, geospatial featurecollections are made explicit by defining a SPARQL query retrieving a set of triples which may be converted to a geodata format.

The following query shows an example which retrieves a FeatureCollection
```
SELECT ?item ?rel ?val ?geo WHERE {
  ?item rdf:type ?class .
  ?class rdfs:subClassOf* geo:Feature .
  ?item ?rel ?val .
  OPTIONAL {?item geo:hasGeometry/geo:hasSerialization ?geo .}
}
```
This SPARQL query retrieves all properties and their values directly connected to an instance of all classes which are subclasses of http://www.opengis.net/ont/geosparql#Feature[geo:Feature].
The query result is a list of triples which may be converted to a FeatureCollection representation.

This representation results in a valid FeatureCollection which may be exposed using an OGC API Features compatibles webservice.

However, it needs to be remarked that the aforementioned query however may not in all cases deliver the the expected result.

There are several reasons for this:

- More information is connected to the instance which should represent the FeatureCollection than anticipated. Maybe only information in a certain namespace is of interest. The solution is to apply FILTER expressions to the SPARQL query
- The aformentioned query only queries directly connected properties and their values. Often geodata formats like GML are hierarchical and therefore need further resolution of property values depicted as URIs. If that is the case the query needs to be adjusted.

==== C.2 Mappings from CQL statements to GeoSPARQL queries

This section presents lists of equivalences between CQL statements and GeoSPARQL statements.

===== C2.1 Query Parameters

Several query parameters may be given as parameters to the HTTP request of the OGC API Features service. These parameters have an influence on the SPARQL query to be executed for the retrieval of a FeatureCollection to be exposed using an OGC API Features compatible service.

|======================
| Query Parameter | Example | SPARQL Expression | Example | Comment
| limit  | limit=5 | LIMIT | LIMIT 5 |
| offset  | offset=10 | OFFSET | OFFSET 10 |
| bbox | bbox=160.6,-55.95,-170,-25.89 | FILTER(geo:sfIntersects()) | FILTER(geo:sfIntersects(?geom,"POLYGON((160.6 -55.95,160.6 -25.89, -170 -25.89, -170 -55.95, 160.6 -55.95))"^^geo:wktLiteral)) | WKT does not define a type boundingbox, therefore a bbox is converted to a Polygon
| datetime | datetime=2018-02-12T23%3A20%3A52Z | | |
|======================


===== C2.2 Literal Values

CQL defines literal values for a variety of datatypes. The following table shows the equivalences of these values in RDF which may be used in any GeoSPARQL query.

|======================
| CQL literal | Examples  | (Geo)SPARQL literal | Examples
| String  | "This is a string" | xsd:string | "This is a string"^^xsd:string 
| Number  | -100  3.14159 | xsd:int xsd:integer xsd:double | "-100"^^xsd:integer  "3.14159"^^xsd:double 
| Boolean  | true false | xsd:boolean| "true"^^xsd:boolean  "false"^^xsd:boolean 
| Spatial Geometry (WKT)  | POINT(1 1) | geo:wktLiteral | "POINT(1 1)"^^geo:wktLiteral
| Spatial Geometry (JSON)  | {"type": "Point", "coordinates":[1,1]} | geo:geoJSONLiteral | "{"type": "Point", "coordinates":[1,1]}"^^geo:geoJSONLiteral
| Temporal Literal  | 1969-07-20  1969-07-20T20:17:40Z | xsd:date xsd:dateTime | "1969-07-20"^^xsd:date "1969-07-20T20:17:40Z"^^xsd:dateTime
|======================

===== C2.3 Property references

CQL allows to reference properties in the FeatureCollection it is targeting for filtering. A property reference is converted to a triple patterns as shown in the following example. A SPARQL variable ?item is assumed to represent the FeatureCollection.

|======================
| Property Reference  | Triple pattern
| name="OGC" | ?item my:name "OGC"^^xsd:string
| number=5 | ?item my:number "5"^^xsd:integer
| number>5 | ?item my:number ?number . FILTER(?number>5)
|======================

===== C2.4 Comparison Predicates

CQL defines comparison predicates to compare two scaler expressions. A comparison predicate is converted to a triple patterns as shown in the following example. A SPARQL variable ?item is assumed to represent the FeatureCollection.

|======================
| Comparison predicate  | Triple pattern | Comment
| name="OGC" | ?item my:name "OGC"^^xsd:string | Equality statements can be converted to a triple pattern
| number=5 | ?item my:number "5"^^xsd:integer | 
| number>5 | ?item my:number ?number . FILTER(?number>5) | Arithmetic comparisons (<,>,>=,<=) are converted to filter expressions
| number BETWEEN 5 AND 10 | ?item my:number ?number . FILTER(?number>=5 && ?number<=10) | BETWEEN statements are converted to arithmetic expressions
| name IN ("OGC","W3C") | VALUES ?namevalues {"OGC" "W3C"} ?item my:name ?namevalues . | IN statements are expressed by VALUES statements
| name IS NOT NULL | EXISTS {?item my:name ?name } | NOT NULL statements are converted to EXIST statements
| name LIKE "OGC." | ?item my:name ?name . FILTER(regex(?name, "OGC.", "i" )) | LIKE statements are converted to SPARQL regex filters
| INTERSECTS(geometry1, geometry2) | FILTER(geof:sfIntersects(?geometry1,?geometry2)) | The INTERSECTS filter statement is converted to a GeoSPARQL FILTER statement
|======================

- Filter CRS parameter equivalent does not yet exist in GeoSPARQL?

===== C2.5 Geospatial Operators

GeoSPARQL includes equivalents of many CQL filter functions as can be seen in the table below.

|======================
| CQL Filter Expression  | GeoSPARQL Filter Function 
| CONTAINS(geometry1,POINT(1 1))  | FILTER(geof:sfContains(?geometry1,"POINT(1 1)"^^geo:wktLiteral))  
| CROSSES(geometry1,geometry2)  | FILTER(geof:sfCrosses(?geometry1,?geometry2))  
| DISJOINT(geometry1,geometry2)  | FILTER(geof:sfDisjoint(?geometry1,?geometry2)) 
| EQUALS(geometry1,geometry2)  | FILTER(geof:sfEquals(?geometry1,?geometry2))  
| INTERSECTS(geometry1,geometry2)  | FILTER(geof:sfIntersects(?geometry1,?geometry2)) 
| OVERLAPS(geometry1,geometry2)  | FILTER(geof:sfOverlaps(?geometry1,?geometry2))  
| TOUCHES(geometry1,geometry2)  | FILTER(geof:sfTouches(?geometry1,?geometry2))  
| WITHIN(geometry1,geometry2)  | FILTER(geof:sfWithin(?geometry1,?geometry2))  
|======================

===== C2.6 Temporal Operators

Temporal operators are currently not part of the GeoSPARQL standard. 

|======================
| CQL Filter Expression  | GeoSPARQL Filter Function 
| beginTime AFTER 1969-07-16T13:32:00Z | 
| beginTime BEFORE 1969-07-16T13:32:00Z |  
| beginTime BEGINS 1969-07-16T13:32:00Z | 
| beginTime BEGUNBY 1969-07-16T13:32:00Z | 
| beginTime DURING 1969-07-16T13:32:00Z | 
| beginTime ENDEDBY 1969-07-16T13:32:00Z | 
| beginTime ENDS 1969-07-16T13:32:00Z | 
| beginTime MEETS 1969-07-16T13:32:00Z |
| beginTime METBY 1969-07-16T13:32:00Z |
| beginTime OVERLAPPEDBY 1969-07-16T13:32:00Z | 
| beginTime TCONTAINS 1969-07-16T13:32:00Z |   
| beginTime TEQUALS 1969-07-16T13:32:00Z |  
| beginTime TOVERLAPS 1969-07-16T13:32:00Z | 
|======================
